use myDB;
create table test03(
	a1 int not null,
	a2 int not null,
	a3 int not null,
	a4 int not null
);
alter table test03 add index idx_a1_a2_a3_a4(a1,a2,a3,a4);
explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a3=3 and a4=4;
+----+-------------+--------+------+-----------------+-----------------+---------+-------------------------+------+-------------+
| id | select_type | table  | type | possible_keys   | key             | key_len | ref                     | rows | Extra       |
+----+-------------+--------+------+-----------------+-----------------+---------+-------------------------+------+-------------+
|  1 | SIMPLE      | test03 | ref  | idx_a1_a2_a3_a4 | idx_a1_a2_a3_a4 | 16      | const,const,const,const |    1 | Using index |
+----+-------------+--------+------+-----------------+-----------------+---------+-------------------------+------+-------------+
推荐写法，因为索引的使用顺序(where后面的顺序)和复合索引的顺序是一致的
explain select a1,a2,a3,a4 from test03 where a4=4 and a3=3 and a2=2 and a1=1;
+----+-------------+--------+------+-----------------+-----------------+---------+-------------------------+------+-------------+
| id | select_type | table  | type | possible_keys   | key             | key_len | ref                     | rows | Extra       |
+----+-------------+--------+------+-----------------+-----------------+---------+-------------------------+------+-------------+
|  1 | SIMPLE      | test03 | ref  | idx_a1_a2_a3_a4 | idx_a1_a2_a3_a4 | 16      | const,const,const,const |    1 | Using index |
+----+-------------+--------+------+-----------------+-----------------+---------+-------------------------+------+-------------+
查询优化器优化了，虽然编写的顺序和索引的顺序不一致，但是sql在真正执行前进过了sql优化器的调整，结果与上条sql是一致的。
以上两个sql使用了全部的复合索引
explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a4=4 order by a3;	a4是无效索引，需要回表查询
+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+
| id | select_type | table  | type | possible_keys   | key             | key_len | ref         | rows | Extra                    |
+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+
|  1 | SIMPLE      | test03 | ref  | idx_a1_a2_a3_a4 | idx_a1_a2_a3_a4 | 8       | const,const |    1 | Using where; Using index |
+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+
以上sql用到了a1、a2两个索引，这两个字段不需要回表查询，using index，而a4因为跨列使用，造成了该索引失效，需要回表查询，
因此是using where，以上可以通过key_len校验。
explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3;
+----+-------------+--------+------+-----------------+-----------------+---------+-------+------+------------------------------------------+
| id | select_type | table  | type | possible_keys   | key             | key_len | ref   | rows | Extra                                    |
+----+-------------+--------+------+-----------------+-----------------+---------+-------+------+------------------------------------------+
|  1 | SIMPLE      | test03 | ref  | idx_a1_a2_a3_a4 | idx_a1_a2_a3_a4 | 4       | const |    1 | Using where; Using index; Using filesort |
+----+-------------+--------+------+-----------------+-----------------+---------+-------+------+------------------------------------------+
using filesort
以上sql出现了using filesort，文件内排序，多了一次额外的排序或查找，本质，就是不要跨列使用(where 和 order by拼起来不要跨列)
explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a2,a3;
[ck]：where 和 order by拼起来，a1+a4+a2+a3,索引顺序为a1,a2,a3. 这里a4不是索引，所以顺序一致。
+----+-------------+--------+------+-----------------+-----------------+---------+-------+------+--------------------------+
| id | select_type | table  | type | possible_keys   | key             | key_len | ref   | rows | Extra                    |
+----+-------------+--------+------+-----------------+-----------------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | test03 | ref  | idx_a1_a2_a3_a4 | idx_a1_a2_a3_a4 | 4       | const |    1 | Using where; Using index |
+----+-------------+--------+------+-----------------+-----------------+---------+-------+------+--------------------------+
以上没有出现using filesort
总结：
	a.如果(a,b,c,d)复合索引和使用的顺序全部一致(且不跨列使用)，则复合索引全部使用。如果部分一致，则使用部分索引。
	b.where和order by拼起来不要跨列

